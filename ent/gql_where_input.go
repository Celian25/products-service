// Code generated by ent, DO NOT EDIT.

package ent

import (
	"errors"
	"fmt"
	"product-backend/ent/category"
	"product-backend/ent/filter"
	"product-backend/ent/filtertype"
	"product-backend/ent/predicate"
	"product-backend/ent/product"
	"time"
)

// CategoryWhereInput represents a where input for filtering Category queries.
type CategoryWhereInput struct {
	Predicates []predicate.Category  `json:"-"`
	Not        *CategoryWhereInput   `json:"not,omitempty"`
	Or         []*CategoryWhereInput `json:"or,omitempty"`
	And        []*CategoryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "slug" field predicates.
	Slug             *string  `json:"slug,omitempty"`
	SlugNEQ          *string  `json:"slugNEQ,omitempty"`
	SlugIn           []string `json:"slugIn,omitempty"`
	SlugNotIn        []string `json:"slugNotIn,omitempty"`
	SlugGT           *string  `json:"slugGT,omitempty"`
	SlugGTE          *string  `json:"slugGTE,omitempty"`
	SlugLT           *string  `json:"slugLT,omitempty"`
	SlugLTE          *string  `json:"slugLTE,omitempty"`
	SlugContains     *string  `json:"slugContains,omitempty"`
	SlugHasPrefix    *string  `json:"slugHasPrefix,omitempty"`
	SlugHasSuffix    *string  `json:"slugHasSuffix,omitempty"`
	SlugEqualFold    *string  `json:"slugEqualFold,omitempty"`
	SlugContainsFold *string  `json:"slugContainsFold,omitempty"`

	// "photo_url" field predicates.
	PhotoURL             *string  `json:"photoURL,omitempty"`
	PhotoURLNEQ          *string  `json:"photoURLNEQ,omitempty"`
	PhotoURLIn           []string `json:"photoURLIn,omitempty"`
	PhotoURLNotIn        []string `json:"photoURLNotIn,omitempty"`
	PhotoURLGT           *string  `json:"photoURLGT,omitempty"`
	PhotoURLGTE          *string  `json:"photoURLGTE,omitempty"`
	PhotoURLLT           *string  `json:"photoURLLT,omitempty"`
	PhotoURLLTE          *string  `json:"photoURLLTE,omitempty"`
	PhotoURLContains     *string  `json:"photoURLContains,omitempty"`
	PhotoURLHasPrefix    *string  `json:"photoURLHasPrefix,omitempty"`
	PhotoURLHasSuffix    *string  `json:"photoURLHasSuffix,omitempty"`
	PhotoURLIsNil        bool     `json:"photoURLIsNil,omitempty"`
	PhotoURLNotNil       bool     `json:"photoURLNotNil,omitempty"`
	PhotoURLEqualFold    *string  `json:"photoURLEqualFold,omitempty"`
	PhotoURLContainsFold *string  `json:"photoURLContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "products" edge predicates.
	HasProducts     *bool                `json:"hasProducts,omitempty"`
	HasProductsWith []*ProductWhereInput `json:"hasProductsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CategoryWhereInput) AddPredicates(predicates ...predicate.Category) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CategoryWhereInput filter on the CategoryQuery builder.
func (i *CategoryWhereInput) Filter(q *CategoryQuery) (*CategoryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCategoryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCategoryWhereInput is returned in case the CategoryWhereInput is empty.
var ErrEmptyCategoryWhereInput = errors.New("ent: empty predicate CategoryWhereInput")

// P returns a predicate for filtering categories.
// An error is returned if the input is empty or invalid.
func (i *CategoryWhereInput) P() (predicate.Category, error) {
	var predicates []predicate.Category
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, category.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Category, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, category.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Category, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, category.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, category.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, category.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, category.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, category.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, category.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, category.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, category.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, category.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, category.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, category.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, category.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, category.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, category.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, category.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, category.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, category.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, category.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, category.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, category.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, category.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, category.NameContainsFold(*i.NameContainsFold))
	}
	if i.Slug != nil {
		predicates = append(predicates, category.SlugEQ(*i.Slug))
	}
	if i.SlugNEQ != nil {
		predicates = append(predicates, category.SlugNEQ(*i.SlugNEQ))
	}
	if len(i.SlugIn) > 0 {
		predicates = append(predicates, category.SlugIn(i.SlugIn...))
	}
	if len(i.SlugNotIn) > 0 {
		predicates = append(predicates, category.SlugNotIn(i.SlugNotIn...))
	}
	if i.SlugGT != nil {
		predicates = append(predicates, category.SlugGT(*i.SlugGT))
	}
	if i.SlugGTE != nil {
		predicates = append(predicates, category.SlugGTE(*i.SlugGTE))
	}
	if i.SlugLT != nil {
		predicates = append(predicates, category.SlugLT(*i.SlugLT))
	}
	if i.SlugLTE != nil {
		predicates = append(predicates, category.SlugLTE(*i.SlugLTE))
	}
	if i.SlugContains != nil {
		predicates = append(predicates, category.SlugContains(*i.SlugContains))
	}
	if i.SlugHasPrefix != nil {
		predicates = append(predicates, category.SlugHasPrefix(*i.SlugHasPrefix))
	}
	if i.SlugHasSuffix != nil {
		predicates = append(predicates, category.SlugHasSuffix(*i.SlugHasSuffix))
	}
	if i.SlugEqualFold != nil {
		predicates = append(predicates, category.SlugEqualFold(*i.SlugEqualFold))
	}
	if i.SlugContainsFold != nil {
		predicates = append(predicates, category.SlugContainsFold(*i.SlugContainsFold))
	}
	if i.PhotoURL != nil {
		predicates = append(predicates, category.PhotoURLEQ(*i.PhotoURL))
	}
	if i.PhotoURLNEQ != nil {
		predicates = append(predicates, category.PhotoURLNEQ(*i.PhotoURLNEQ))
	}
	if len(i.PhotoURLIn) > 0 {
		predicates = append(predicates, category.PhotoURLIn(i.PhotoURLIn...))
	}
	if len(i.PhotoURLNotIn) > 0 {
		predicates = append(predicates, category.PhotoURLNotIn(i.PhotoURLNotIn...))
	}
	if i.PhotoURLGT != nil {
		predicates = append(predicates, category.PhotoURLGT(*i.PhotoURLGT))
	}
	if i.PhotoURLGTE != nil {
		predicates = append(predicates, category.PhotoURLGTE(*i.PhotoURLGTE))
	}
	if i.PhotoURLLT != nil {
		predicates = append(predicates, category.PhotoURLLT(*i.PhotoURLLT))
	}
	if i.PhotoURLLTE != nil {
		predicates = append(predicates, category.PhotoURLLTE(*i.PhotoURLLTE))
	}
	if i.PhotoURLContains != nil {
		predicates = append(predicates, category.PhotoURLContains(*i.PhotoURLContains))
	}
	if i.PhotoURLHasPrefix != nil {
		predicates = append(predicates, category.PhotoURLHasPrefix(*i.PhotoURLHasPrefix))
	}
	if i.PhotoURLHasSuffix != nil {
		predicates = append(predicates, category.PhotoURLHasSuffix(*i.PhotoURLHasSuffix))
	}
	if i.PhotoURLIsNil {
		predicates = append(predicates, category.PhotoURLIsNil())
	}
	if i.PhotoURLNotNil {
		predicates = append(predicates, category.PhotoURLNotNil())
	}
	if i.PhotoURLEqualFold != nil {
		predicates = append(predicates, category.PhotoURLEqualFold(*i.PhotoURLEqualFold))
	}
	if i.PhotoURLContainsFold != nil {
		predicates = append(predicates, category.PhotoURLContainsFold(*i.PhotoURLContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, category.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, category.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, category.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, category.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, category.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, category.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, category.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, category.CreatedAtLTE(*i.CreatedAtLTE))
	}

	if i.HasProducts != nil {
		p := category.HasProducts()
		if !*i.HasProducts {
			p = category.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProductsWith) > 0 {
		with := make([]predicate.Product, 0, len(i.HasProductsWith))
		for _, w := range i.HasProductsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProductsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, category.HasProductsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCategoryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return category.And(predicates...), nil
	}
}

// FilterWhereInput represents a where input for filtering Filter queries.
type FilterWhereInput struct {
	Predicates []predicate.Filter  `json:"-"`
	Not        *FilterWhereInput   `json:"not,omitempty"`
	Or         []*FilterWhereInput `json:"or,omitempty"`
	And        []*FilterWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "filter_type" edge predicates.
	HasFilterType     *bool                   `json:"hasFilterType,omitempty"`
	HasFilterTypeWith []*FilterTypeWhereInput `json:"hasFilterTypeWith,omitempty"`

	// "products" edge predicates.
	HasProducts     *bool                `json:"hasProducts,omitempty"`
	HasProductsWith []*ProductWhereInput `json:"hasProductsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *FilterWhereInput) AddPredicates(predicates ...predicate.Filter) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the FilterWhereInput filter on the FilterQuery builder.
func (i *FilterWhereInput) Filter(q *FilterQuery) (*FilterQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyFilterWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyFilterWhereInput is returned in case the FilterWhereInput is empty.
var ErrEmptyFilterWhereInput = errors.New("ent: empty predicate FilterWhereInput")

// P returns a predicate for filtering filters.
// An error is returned if the input is empty or invalid.
func (i *FilterWhereInput) P() (predicate.Filter, error) {
	var predicates []predicate.Filter
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, filter.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Filter, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, filter.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Filter, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, filter.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, filter.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, filter.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, filter.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, filter.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, filter.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, filter.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, filter.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, filter.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, filter.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, filter.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, filter.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, filter.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, filter.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, filter.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, filter.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, filter.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, filter.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, filter.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, filter.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, filter.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, filter.NameContainsFold(*i.NameContainsFold))
	}

	if i.HasFilterType != nil {
		p := filter.HasFilterType()
		if !*i.HasFilterType {
			p = filter.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasFilterTypeWith) > 0 {
		with := make([]predicate.FilterType, 0, len(i.HasFilterTypeWith))
		for _, w := range i.HasFilterTypeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasFilterTypeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, filter.HasFilterTypeWith(with...))
	}
	if i.HasProducts != nil {
		p := filter.HasProducts()
		if !*i.HasProducts {
			p = filter.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProductsWith) > 0 {
		with := make([]predicate.Product, 0, len(i.HasProductsWith))
		for _, w := range i.HasProductsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProductsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, filter.HasProductsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyFilterWhereInput
	case 1:
		return predicates[0], nil
	default:
		return filter.And(predicates...), nil
	}
}

// FilterTypeWhereInput represents a where input for filtering FilterType queries.
type FilterTypeWhereInput struct {
	Predicates []predicate.FilterType  `json:"-"`
	Not        *FilterTypeWhereInput   `json:"not,omitempty"`
	Or         []*FilterTypeWhereInput `json:"or,omitempty"`
	And        []*FilterTypeWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "tech_name" field predicates.
	TechName             *string  `json:"techName,omitempty"`
	TechNameNEQ          *string  `json:"techNameNEQ,omitempty"`
	TechNameIn           []string `json:"techNameIn,omitempty"`
	TechNameNotIn        []string `json:"techNameNotIn,omitempty"`
	TechNameGT           *string  `json:"techNameGT,omitempty"`
	TechNameGTE          *string  `json:"techNameGTE,omitempty"`
	TechNameLT           *string  `json:"techNameLT,omitempty"`
	TechNameLTE          *string  `json:"techNameLTE,omitempty"`
	TechNameContains     *string  `json:"techNameContains,omitempty"`
	TechNameHasPrefix    *string  `json:"techNameHasPrefix,omitempty"`
	TechNameHasSuffix    *string  `json:"techNameHasSuffix,omitempty"`
	TechNameIsNil        bool     `json:"techNameIsNil,omitempty"`
	TechNameNotNil       bool     `json:"techNameNotNil,omitempty"`
	TechNameEqualFold    *string  `json:"techNameEqualFold,omitempty"`
	TechNameContainsFold *string  `json:"techNameContainsFold,omitempty"`

	// "filters" edge predicates.
	HasFilters     *bool               `json:"hasFilters,omitempty"`
	HasFiltersWith []*FilterWhereInput `json:"hasFiltersWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *FilterTypeWhereInput) AddPredicates(predicates ...predicate.FilterType) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the FilterTypeWhereInput filter on the FilterTypeQuery builder.
func (i *FilterTypeWhereInput) Filter(q *FilterTypeQuery) (*FilterTypeQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyFilterTypeWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyFilterTypeWhereInput is returned in case the FilterTypeWhereInput is empty.
var ErrEmptyFilterTypeWhereInput = errors.New("ent: empty predicate FilterTypeWhereInput")

// P returns a predicate for filtering filtertypes.
// An error is returned if the input is empty or invalid.
func (i *FilterTypeWhereInput) P() (predicate.FilterType, error) {
	var predicates []predicate.FilterType
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, filtertype.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.FilterType, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, filtertype.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.FilterType, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, filtertype.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, filtertype.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, filtertype.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, filtertype.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, filtertype.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, filtertype.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, filtertype.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, filtertype.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, filtertype.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, filtertype.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, filtertype.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, filtertype.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, filtertype.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, filtertype.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, filtertype.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, filtertype.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, filtertype.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, filtertype.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, filtertype.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, filtertype.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, filtertype.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, filtertype.NameContainsFold(*i.NameContainsFold))
	}
	if i.TechName != nil {
		predicates = append(predicates, filtertype.TechNameEQ(*i.TechName))
	}
	if i.TechNameNEQ != nil {
		predicates = append(predicates, filtertype.TechNameNEQ(*i.TechNameNEQ))
	}
	if len(i.TechNameIn) > 0 {
		predicates = append(predicates, filtertype.TechNameIn(i.TechNameIn...))
	}
	if len(i.TechNameNotIn) > 0 {
		predicates = append(predicates, filtertype.TechNameNotIn(i.TechNameNotIn...))
	}
	if i.TechNameGT != nil {
		predicates = append(predicates, filtertype.TechNameGT(*i.TechNameGT))
	}
	if i.TechNameGTE != nil {
		predicates = append(predicates, filtertype.TechNameGTE(*i.TechNameGTE))
	}
	if i.TechNameLT != nil {
		predicates = append(predicates, filtertype.TechNameLT(*i.TechNameLT))
	}
	if i.TechNameLTE != nil {
		predicates = append(predicates, filtertype.TechNameLTE(*i.TechNameLTE))
	}
	if i.TechNameContains != nil {
		predicates = append(predicates, filtertype.TechNameContains(*i.TechNameContains))
	}
	if i.TechNameHasPrefix != nil {
		predicates = append(predicates, filtertype.TechNameHasPrefix(*i.TechNameHasPrefix))
	}
	if i.TechNameHasSuffix != nil {
		predicates = append(predicates, filtertype.TechNameHasSuffix(*i.TechNameHasSuffix))
	}
	if i.TechNameIsNil {
		predicates = append(predicates, filtertype.TechNameIsNil())
	}
	if i.TechNameNotNil {
		predicates = append(predicates, filtertype.TechNameNotNil())
	}
	if i.TechNameEqualFold != nil {
		predicates = append(predicates, filtertype.TechNameEqualFold(*i.TechNameEqualFold))
	}
	if i.TechNameContainsFold != nil {
		predicates = append(predicates, filtertype.TechNameContainsFold(*i.TechNameContainsFold))
	}

	if i.HasFilters != nil {
		p := filtertype.HasFilters()
		if !*i.HasFilters {
			p = filtertype.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasFiltersWith) > 0 {
		with := make([]predicate.Filter, 0, len(i.HasFiltersWith))
		for _, w := range i.HasFiltersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasFiltersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, filtertype.HasFiltersWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyFilterTypeWhereInput
	case 1:
		return predicates[0], nil
	default:
		return filtertype.And(predicates...), nil
	}
}

// ProductWhereInput represents a where input for filtering Product queries.
type ProductWhereInput struct {
	Predicates []predicate.Product  `json:"-"`
	Not        *ProductWhereInput   `json:"not,omitempty"`
	Or         []*ProductWhereInput `json:"or,omitempty"`
	And        []*ProductWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "slug" field predicates.
	Slug             *string  `json:"slug,omitempty"`
	SlugNEQ          *string  `json:"slugNEQ,omitempty"`
	SlugIn           []string `json:"slugIn,omitempty"`
	SlugNotIn        []string `json:"slugNotIn,omitempty"`
	SlugGT           *string  `json:"slugGT,omitempty"`
	SlugGTE          *string  `json:"slugGTE,omitempty"`
	SlugLT           *string  `json:"slugLT,omitempty"`
	SlugLTE          *string  `json:"slugLTE,omitempty"`
	SlugContains     *string  `json:"slugContains,omitempty"`
	SlugHasPrefix    *string  `json:"slugHasPrefix,omitempty"`
	SlugHasSuffix    *string  `json:"slugHasSuffix,omitempty"`
	SlugEqualFold    *string  `json:"slugEqualFold,omitempty"`
	SlugContainsFold *string  `json:"slugContainsFold,omitempty"`

	// "photo_url" field predicates.
	PhotoURL             *string  `json:"photoURL,omitempty"`
	PhotoURLNEQ          *string  `json:"photoURLNEQ,omitempty"`
	PhotoURLIn           []string `json:"photoURLIn,omitempty"`
	PhotoURLNotIn        []string `json:"photoURLNotIn,omitempty"`
	PhotoURLGT           *string  `json:"photoURLGT,omitempty"`
	PhotoURLGTE          *string  `json:"photoURLGTE,omitempty"`
	PhotoURLLT           *string  `json:"photoURLLT,omitempty"`
	PhotoURLLTE          *string  `json:"photoURLLTE,omitempty"`
	PhotoURLContains     *string  `json:"photoURLContains,omitempty"`
	PhotoURLHasPrefix    *string  `json:"photoURLHasPrefix,omitempty"`
	PhotoURLHasSuffix    *string  `json:"photoURLHasSuffix,omitempty"`
	PhotoURLIsNil        bool     `json:"photoURLIsNil,omitempty"`
	PhotoURLNotNil       bool     `json:"photoURLNotNil,omitempty"`
	PhotoURLEqualFold    *string  `json:"photoURLEqualFold,omitempty"`
	PhotoURLContainsFold *string  `json:"photoURLContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "category" edge predicates.
	HasCategory     *bool                 `json:"hasCategory,omitempty"`
	HasCategoryWith []*CategoryWhereInput `json:"hasCategoryWith,omitempty"`

	// "filters" edge predicates.
	HasFilters     *bool               `json:"hasFilters,omitempty"`
	HasFiltersWith []*FilterWhereInput `json:"hasFiltersWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ProductWhereInput) AddPredicates(predicates ...predicate.Product) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ProductWhereInput filter on the ProductQuery builder.
func (i *ProductWhereInput) Filter(q *ProductQuery) (*ProductQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyProductWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyProductWhereInput is returned in case the ProductWhereInput is empty.
var ErrEmptyProductWhereInput = errors.New("ent: empty predicate ProductWhereInput")

// P returns a predicate for filtering products.
// An error is returned if the input is empty or invalid.
func (i *ProductWhereInput) P() (predicate.Product, error) {
	var predicates []predicate.Product
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, product.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Product, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, product.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Product, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, product.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, product.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, product.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, product.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, product.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, product.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, product.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, product.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, product.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, product.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, product.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, product.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, product.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, product.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, product.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, product.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, product.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, product.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, product.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, product.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, product.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, product.NameContainsFold(*i.NameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, product.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, product.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, product.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, product.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, product.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, product.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, product.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, product.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, product.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, product.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, product.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, product.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, product.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, product.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, product.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.Slug != nil {
		predicates = append(predicates, product.SlugEQ(*i.Slug))
	}
	if i.SlugNEQ != nil {
		predicates = append(predicates, product.SlugNEQ(*i.SlugNEQ))
	}
	if len(i.SlugIn) > 0 {
		predicates = append(predicates, product.SlugIn(i.SlugIn...))
	}
	if len(i.SlugNotIn) > 0 {
		predicates = append(predicates, product.SlugNotIn(i.SlugNotIn...))
	}
	if i.SlugGT != nil {
		predicates = append(predicates, product.SlugGT(*i.SlugGT))
	}
	if i.SlugGTE != nil {
		predicates = append(predicates, product.SlugGTE(*i.SlugGTE))
	}
	if i.SlugLT != nil {
		predicates = append(predicates, product.SlugLT(*i.SlugLT))
	}
	if i.SlugLTE != nil {
		predicates = append(predicates, product.SlugLTE(*i.SlugLTE))
	}
	if i.SlugContains != nil {
		predicates = append(predicates, product.SlugContains(*i.SlugContains))
	}
	if i.SlugHasPrefix != nil {
		predicates = append(predicates, product.SlugHasPrefix(*i.SlugHasPrefix))
	}
	if i.SlugHasSuffix != nil {
		predicates = append(predicates, product.SlugHasSuffix(*i.SlugHasSuffix))
	}
	if i.SlugEqualFold != nil {
		predicates = append(predicates, product.SlugEqualFold(*i.SlugEqualFold))
	}
	if i.SlugContainsFold != nil {
		predicates = append(predicates, product.SlugContainsFold(*i.SlugContainsFold))
	}
	if i.PhotoURL != nil {
		predicates = append(predicates, product.PhotoURLEQ(*i.PhotoURL))
	}
	if i.PhotoURLNEQ != nil {
		predicates = append(predicates, product.PhotoURLNEQ(*i.PhotoURLNEQ))
	}
	if len(i.PhotoURLIn) > 0 {
		predicates = append(predicates, product.PhotoURLIn(i.PhotoURLIn...))
	}
	if len(i.PhotoURLNotIn) > 0 {
		predicates = append(predicates, product.PhotoURLNotIn(i.PhotoURLNotIn...))
	}
	if i.PhotoURLGT != nil {
		predicates = append(predicates, product.PhotoURLGT(*i.PhotoURLGT))
	}
	if i.PhotoURLGTE != nil {
		predicates = append(predicates, product.PhotoURLGTE(*i.PhotoURLGTE))
	}
	if i.PhotoURLLT != nil {
		predicates = append(predicates, product.PhotoURLLT(*i.PhotoURLLT))
	}
	if i.PhotoURLLTE != nil {
		predicates = append(predicates, product.PhotoURLLTE(*i.PhotoURLLTE))
	}
	if i.PhotoURLContains != nil {
		predicates = append(predicates, product.PhotoURLContains(*i.PhotoURLContains))
	}
	if i.PhotoURLHasPrefix != nil {
		predicates = append(predicates, product.PhotoURLHasPrefix(*i.PhotoURLHasPrefix))
	}
	if i.PhotoURLHasSuffix != nil {
		predicates = append(predicates, product.PhotoURLHasSuffix(*i.PhotoURLHasSuffix))
	}
	if i.PhotoURLIsNil {
		predicates = append(predicates, product.PhotoURLIsNil())
	}
	if i.PhotoURLNotNil {
		predicates = append(predicates, product.PhotoURLNotNil())
	}
	if i.PhotoURLEqualFold != nil {
		predicates = append(predicates, product.PhotoURLEqualFold(*i.PhotoURLEqualFold))
	}
	if i.PhotoURLContainsFold != nil {
		predicates = append(predicates, product.PhotoURLContainsFold(*i.PhotoURLContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, product.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, product.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, product.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, product.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, product.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, product.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, product.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, product.CreatedAtLTE(*i.CreatedAtLTE))
	}

	if i.HasCategory != nil {
		p := product.HasCategory()
		if !*i.HasCategory {
			p = product.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCategoryWith) > 0 {
		with := make([]predicate.Category, 0, len(i.HasCategoryWith))
		for _, w := range i.HasCategoryWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCategoryWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, product.HasCategoryWith(with...))
	}
	if i.HasFilters != nil {
		p := product.HasFilters()
		if !*i.HasFilters {
			p = product.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasFiltersWith) > 0 {
		with := make([]predicate.Filter, 0, len(i.HasFiltersWith))
		for _, w := range i.HasFiltersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasFiltersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, product.HasFiltersWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyProductWhereInput
	case 1:
		return predicates[0], nil
	default:
		return product.And(predicates...), nil
	}
}
